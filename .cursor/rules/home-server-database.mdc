---
description: 
globs: 
alwaysApply: true
---
# Shared Package Database Patterns

## Repository Pattern
- Each model has a corresponding repository class
- Base repository provides common CRUD operations
- Repositories handle both PostgreSQL and Redis operations
- Redis is used purely as a cache layer
- PostgreSQL is the source of truth

## Cache Strategy
```python
# Writing
1. Save to PostgreSQL
2. Invalidate Redis cache

# Reading
1. Try Redis first
2. Fallback to PostgreSQL if not in cache
3. Update Redis cache with PostgreSQL data
```

## Key Conventions
- Redis keys: `{model_prefix}:{unique_id}`
- Example: `webpage:https://example.com`
- Cache expiration: 1 hour default
- Cache invalidation on writes

## Model Requirements
1. SQLAlchemy model class
2. Redis serialization methods:
```python
def to_redis_data(self) -> dict:
    """Convert to Redis format"""

@classmethod
def from_redis_data(cls, data: dict) -> Self:
    """Create from Redis data"""
```

## Repository Structure
```python
class ModelRepository(BaseRepository):
    def _get_prefix(self) -> str:
        """Redis key prefix"""
    
    def _get_entity_key(self, entity) -> str:
        """Unique entity identifier"""
    
    def _to_redis_data(self, entity) -> dict:
        """Use model's to_redis_data"""
    
    def _from_redis_data(self, data: dict) -> Model:
        """Use model's from_redis_data"""
```

## Usage Example
```python
from agent_utils import DatabaseContext, DatabaseConfig

config = DatabaseConfig(
    postgres_host="home.server",
    postgres_password=os.getenv("POSTGRES_PASSWORD")
)

async with DatabaseContext(config=config) as db:
    # Single entity operations (with caching)
    entity = await db.repository.get_by_id(id)
    await db.repository.save(entity)
    
    # Bulk operations (no caching)
    items = await db.repository.get_recent(limit=10)
```

## Error Handling
- Redis errors are caught and logged
- Redis failures don't affect PostgreSQL operations
- All database operations are logged appropriately
- Transactions are used for PostgreSQL operations

## Cache Operations
1. Single-entity reads: Cached
2. Bulk operations: Not cached
3. Search operations: Not cached
4. List operations: Not cached
5. Cache cleared on:
   - Entity deletion
   - Table truncation
   - Manual invalidation

## Best Practices
1. Use repositories instead of direct SQL
2. Handle both PostgreSQL and Redis errors
3. Use transactions for multi-step operations
4. Follow key naming conventions
5. Implement proper cache invalidation
6. Log all database operations
7. Use type hints consistently
8. Document cache behavior 